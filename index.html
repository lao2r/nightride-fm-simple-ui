<html>

<head>
    <base href="https://nightride.fm/">
    <title>Synthwave Radio - NightRide.fm</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Orbitron', sans-serif;
            background-color: #171615;
            color: #beb6a9;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        .container {
            CONTAIN-INTRINSIC-BLOCK-SIZE: AUTO 100PX;
            position: relative;
            width: 100%;
            max-width: 800px;
            max-height: 600px;
            height: 99.5%;
            border-radius: 10px;
            box-shadow: 0 0 10px;
            overflow: hidden;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .overlay.noise {
            z-index: 800;
            animation: grain 8s steps(10) infinite;
            background-image: url(https://nightride.fm/static/img/noise.png);
            height: 400%;
            left: -50%;
            top: -150%;
            width: 300%;
            background-size: auto;
            opacity: .2;
        }

        .overlay.scanline {
            z-index: 1010;
            animation: scanline 7.77s linear infinite;
            background: linear-gradient(to bottom,
                    transparent 80%,
                    rgba(0, 0, 0, 0.3) 90%);
            background-size: 100% 4px;
            background-repeat: repeat-x;
        }

        @keyframes grain {

            0%,
            100% {
                transform: translate(0, 0);
            }

            10% {
                transform: translate(-5%, -10%);
            }

            20% {
                transform: translate(-15%, 5%);
            }

            30% {
                transform: translate(7%, -25%);
            }

            40% {
                transform: translate(-5%, 25%);
            }

            50% {
                transform: translate(-15%, 10%);
            }

            60% {
                transform: translate(15%, 0%);
            }

            70% {
                transform: translate(0%, 15%);
            }

            80% {
                transform: translate(3%, 35%);
            }

            90% {
                transform: translate(-10%, 10%);
            }
        }

        @keyframes scanline {
            100% {
                transform: translateY(0);
            }

            0% {
                transform: translateY(100%);
            }
        }

        .logo {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            text-shadow: 0 0 10px;
            user-select: none;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            height: 220px;
            user-select: none;
            outline: none;
        }

        .btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.3s ease;
            width: 30px;
            user-select: none;
            outline: none;
        }

        .btn:hover svg {
            filter: drop-shadow(2px 2px 5px rgba(0, 0, 0, 0.3));
        }

        .btn svg {
            transition: filter 0.3s ease;
            filter: drop-shadow(0px 0px 2px rgb(255, 255, 255));
        }

        .volume-bar {
            width: 100px;
            left: 10;
            height: 5px;
            position: relative;
            border-radius: 5px;
            overflow: hidden;
            transition: box-shadow 0.3s ease;
            user-select: none;
        }

        .volume-bar:hover {
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        .volume-level {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 50%;
            box-shadow: 0 0 10px;
            user-select: none;
        }

        #status {
            position: absolute;
            top: 60px;
            left: 20px;
            text-shadow: 0 0 black;
            font-size: 14px;
            user-select: none;
        }

        #currentInfo {
            position: absolute;
            top: 80px;
            left: 20px;
            text-shadow: 0 0 black;
            font-size: 14px;
            user-select: none;
        }

        canvas {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
        }

        #frequencyCanvas {
            top: 50%;
            transform: translateY(-50%);
            user-select: none;
        }

        .style-buttons {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            width: 90%;
            user-select: none;
            outline: none;
        }

        .style-btn {
            background: #00000075;
            border: 1px solid;
            font-size: 12px;
            cursor: pointer;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            transition: all 0.3s ease;
            user-select: none;
            outline: none;
        }

        .style-btn:hover,
        .style-btn.active {
            color: #171615;
        }

        /* Chillsynth - unchanged */
        body.chillsynth {
            /* background-color: #d39b6ef0; */
            color: #beb6a9;
        }

        .chillsynth .container {
            background: linear-gradient(45deg, #3a1c3d, #251320);
            border: 2px solid #a923c2;
            box-shadow: 0 0 10px #e02cd2;
        }

        .chillsynth .logo {
            color: #d8faf2;
            text-shadow: 0 0 10px #84e7ff;
        }

        .chillsynth .btn {
            color: #d8faf2;
        }

        .chillsynth .btn:hover {
            text-shadow: 0 0 10px #e02cd2;
        }

        .chillsynth .volume-bar {
            background: #435155;
        }

        .chillsynth .volume-level {
            background: linear-gradient(90deg, #a923c2, #e02cd2);
            box-shadow: 0 0 10px #e02cd2;
        }

        .chillsynth #currentInfo {
            color: #e02cd2;
        }

        .chillsynth .style-btn {
            border-color: #a923c2;
            color: #d8faf2;
        }

        .chillsynth .style-btn:hover,
        .chillsynth .style-btn.active {
            background-color: #a923c2;
        }
        
        .chillsynth .btn svg {
            transition: filter 0.3s ease;
            filter: drop-shadow(0px 0px 3px #a923c2);
        }

        .chillsynth .btn:hover svg {
            filter: drop-shadow(2px 2px 5px rgba(0, 0, 0, 0.3));
        }

        /* Nightride - Blade Runner inspired */
        body.nightride {
            background-color: #171615;
            color: #66fcf1;
        }

        .nightride .container {
            background: linear-gradient(45deg, #1f2833, #0b0c10);
            border: 2px solid #45a29e;
            box-shadow: 0 0 10px #66fcf1;
        }

        .nightride .logo {
            color: #66fcf1;
            text-shadow: 0 0 10px #45a29e;
        }

        .nightride .btn {
            color: #66fcf1;
        }

        .nightride .btn:hover {
            text-shadow: 0 0 10px #45a29e;
        }

        .nightride .volume-bar {
            background: #1f2833;
        }

        .nightride .volume-level {
            background: linear-gradient(90deg, #45a29e, #66fcf1);
            box-shadow: 0 0 10px #66fcf1;
        }

        .nightride #currentInfo {
            color: #45a29e;
        }

        .nightride .style-btn {
            border-color: #45a29e;
            color: #66fcf1;
        }

        .nightride .style-btn:hover,
        .nightride .style-btn.active {
            background-color: #45a29e;
        }

        .nightride .btn svg {
            transition: filter 0.3s ease;
            filter: drop-shadow(0px 0px 3px #45a29e);
        }

        .nightride .btn:hover svg {
            filter: drop-shadow(2px 2px 5px rgba(0, 0, 0, 0.3));
        }

        /* Datawave - 80s Computer Terminal */
        body.datawave {
            background-color: #171615;
            color: #00ff00;
        }

        .datawave .container {
            background: linear-gradient(45deg, #001100, #002200);
            border: 2px solid #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }

        .datawave .logo {
            color: #00ff00;
            text-shadow: 0 0 10px #00aa00;
        }

        .datawave .btn {
            color: #00ff00;
        }

        .datawave .btn:hover {
            text-shadow: 0 0 10px #00aa00;
        }

        .datawave .volume-bar {
            background: #001100;
        }

        .datawave .volume-level {
            background: linear-gradient(90deg, #00aa00, #00ff00);
            box-shadow: 0 0 10px #00ff00;
        }

        .datawave #currentInfo {
            color: #00aa00;
        }

        .datawave .style-btn {
            border-color: #00aa00;
            color: #00ff00;
        }

        .datawave .style-btn:hover,
        .datawave .style-btn.active {
            background-color: #00aa00;
        }

        .datawave .btn svg {
            transition: filter 0.3s ease;
            filter: drop-shadow(0px 0px 3px #00aa00);
        }

        .datawave .btn:hover svg {
            filter: drop-shadow(2px 2px 5px rgba(0, 0, 0, 0.3));
        }

        /* Spacesynth - 80s Sci-Fi */
        body.spacesynth {
            background-color: #171615;
            color: #e762d7;
        }

        .spacesynth .container {
            background: linear-gradient(45deg, #1e1637, #0c0b13);
            border: 2px solid #e762d7;
            box-shadow: 0 0 10px #b52cc7;
        }

        .spacesynth .logo {
            color: #e762d7;
            text-shadow: 0 0 10px #b52cc7;
        }

        .spacesynth .btn {
            color: #e762d7;
        }

        .spacesynth .btn:hover {
            text-shadow: 0 0 10px #b52cc7;
        }

        .spacesynth .volume-bar {
            background: #1e1637;
        }

        .spacesynth .volume-level {
            background: linear-gradient(90deg, #b52cc7, #e762d7);
            box-shadow: 0 0 10px #e762d7;
        }

        .spacesynth #currentInfo {
            color: #b52cc7;
        }

        .spacesynth .style-btn {
            border-color: #b52cc7;
            color: #e762d7;
        }

        .spacesynth .style-btn:hover,
        .spacesynth .style-btn.active {
            background-color: #b52cc7;
        }

        .spacesynth .btn svg {
            transition: filter 0.3s ease;
            filter: drop-shadow(0px 0px 3px #b52cc7);
        }

        .spacesynth .btn:hover svg {
            filter: drop-shadow(2px 2px 5px rgba(0, 0, 0, 0.3));
        }

        /* Darksynth - Terminator inspired */
        body.darksynth {
            background-color: #171615;
            color: #ff3c00;
        }

        .darksynth .container {
            background: linear-gradient(45deg, #2b2b2b, #1a1a1a);
            border: 2px solid #ff3c00;
            box-shadow: 0 0 10px #ff3c00;
        }

        .darksynth .logo {
            color: #ff3c00;
            text-shadow: 0 0 10px #b32900;
        }

        .darksynth .btn {
            color: #ff3c00;
        }

        .darksynth .btn:hover {
            text-shadow: 0 0 10px #b32900;
        }

        .darksynth .volume-bar {
            background: #2b2b2b;
        }

        .darksynth .volume-level {
            background: linear-gradient(90deg, #b32900, #ff3c00);
            box-shadow: 0 0 10px #ff3c00;
        }

        .darksynth #currentInfo {
            color: #b32900;
        }

        .darksynth .style-btn {
            border-color: #b32900;
            color: #ff3c00;
        }

        .darksynth .style-btn:hover,
        .darksynth .style-btn.active {
            background-color: #b32900;
        }

        .darksynth .btn svg {
            transition: filter 0.3s ease;
            filter: drop-shadow(0px 0px 3px #b32900);
        }

        .darksynth .btn:hover svg {
            filter: drop-shadow(2px 2px 5px rgba(0, 0, 0, 0.3));
        }

        /* Horrorsynth - 80s Horror */
        body.horrorsynth {
            background-color: #171615;
            color: #ff0000;
        }

        .horrorsynth .container {
            background: linear-gradient(45deg, #1a0000, #000000);
            border: 2px solid #ff0000;
            box-shadow: 0 0 10px #800000;
        }

        .horrorsynth .logo {
            color: #ff0000;
            text-shadow: 0 0 10px #800000;
        }

        .horrorsynth .btn {
            color: #ff0000;
        }

        .horrorsynth .btn:hover {
            text-shadow: 0 0 10px #800000;
        }

        .horrorsynth .volume-bar {
            background: #1a0000;
        }

        .horrorsynth .volume-level {
            background: linear-gradient(90deg, #800000, #ff0000);
            box-shadow: 0 0 10px #ff0000;
        }

        .horrorsynth #currentInfo {
            color: #800000;
        }

        .horrorsynth .style-btn {
            border-color: #800000;
            color: #ff0000;
        }

        .horrorsynth .style-btn:hover,
        .horrorsynth .style-btn.active {
            background-color: #800000;
        }

        .horrorsynth .btn svg {
            transition: filter 0.3s ease;
            filter: drop-shadow(0px 0px 3px #800000);
        }

        .horrorsynth .btn:hover svg {
            filter: drop-shadow(2px 2px 5px rgba(0, 0, 0, 0.3));
        }

        /* EBSM - 90s Electronica */
        body.ebsm {
            background-color: #171615;
            color: #00ffff;
        }

        .ebsm .container {
            background: linear-gradient(45deg, #000066, #000033);
            border: 2px solid #00ffff;
            box-shadow: 0 0 10px #0080ff;
        }

        .ebsm .logo {
            color: #00ffff;
            text-shadow: 0 0 10px #0080ff;
        }

        .ebsm .btn {
            color: #00ffff;
        }

        .ebsm .btn:hover {
            text-shadow: 0 0 10px #0080ff;
        }

        .ebsm .volume-bar {
            background: #000066;
        }

        .ebsm .volume-level {
            background: linear-gradient(90deg, #0080ff, #00ffff);
            box-shadow: 0 0 10px #00ffff;
        }

        .ebsm #currentInfo {
            color: #0080ff;
        }

        .ebsm .style-btn {
            border-color: #0080ff;
            color: #00ffff;
        }

        .ebsm .style-btn:hover,
        .ebsm .style-btn.active {
            background-color: #0080ff;
        }

        .ebsm .btn svg {
            transition: filter 0.3s ease;
            filter: drop-shadow(0px 0px 3px #0080ff);
        }

        .ebsm .btn svg {
            transition: filter 0.3s ease;
            filter: drop-shadow(0px 0px 3px #0080ff);
        }

        .ebsm .btn:hover svg {
            filter: drop-shadow(2px 2px 5px rgba(0, 0, 0, 0.3));
        }

    </style>
</head>

<body class="chillsynth">
    <div class="container">
        <div class="overlay noise"></div>
        <div class="overlay scanlines __web-inspector-hide-shortcut__"></div>
        <div class="overlay scanline"></div>
        <div class="logo"><a style="color: inherit; text-decoration: none;">NIGHTRIDE.FM</a></div>
        <div id="status">Ready to play</div>
        <div id="currentInfo"></div>
        <canvas id="frequencyCanvas"></canvas>
        <canvas id="barsCanvas"></canvas>
        <div class="controls" style="top: 40px;">
            <button id="playBtn" class="btn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white">
                <path d="M8 5v14l11-7z"/></svg></button>
            <button id="muteBtn" class="btn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white">
                <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg></button>
            <div class="volume-bar" style="cursor: pointer;">
                <div class="volume-level"></div>
            </div>
        </div>
        <div class="style-buttons">
            <button class="style-btn" data-style="nightride">NIGHTRIDE</button>
            <button class="style-btn active" data-style="chillsynth">CHILLSYNTH</button>
            <button class="style-btn" data-style="datawave">DATAWAVE</button>
            <button class="style-btn" data-style="spacesynth">SPACESYNTH</button>
            <button class="style-btn" data-style="darksynth">DARKSYNTH</button>
            <button class="style-btn" data-style="horrorsynth">HORRORSYNTH</button>
            <button class="style-btn" data-style="ebsm">EBSM</button>
        </div>
    </div>

<script>
    // Polyfill for requestAnimationFrame (оставляем без изменений)
    (function() {
        // ... (ваш существующий полифилл) ...
        console.log("requestAnimationFrame initialized.");
    }());

    let audioElement;
    let playing = false;
    let audioContext; // Контекст будет создан позже
    let analyser;
    let sourceNode; // Добавим переменную для источника
    let isMuted = false;
    let animationId;
    let currentStyle = 'chillsynth';
    let metaInfo = {};
    let userInteracted = false; // Флаг первого взаимодействия

    const playBtn = document.getElementById('playBtn');
    const muteBtn = document.getElementById('muteBtn');
    const status = document.getElementById('status');
    const currentInfo = document.getElementById('currentInfo');
    const volumeControl = document.querySelector('.volume-level');
    const volumeBar = document.querySelector('.volume-bar');
    const frequencyCanvas = document.getElementById('frequencyCanvas');
    const barsCanvas = document.getElementById('barsCanvas');
    const styleButtons = document.querySelectorAll('.style-btn');
    // Убираем userInteractionDiv, так как первое нажатие на Play будет взаимодействием
    // const userInteractionDiv = document.getElementById('user-interaction');

    // --- Остальные обработчики событий и функции (без изменений) ---

    document.addEventListener('keydown', (event) => {
        if (event.key === 'Tab' || (event.ctrlKey && event.shiftKey && event.key === 'I') || event.key === ' ' || (event.ctrlKey && event.key === 'R') || (event.ctrlKey && event.shiftKey && event.key === 'R')) {
            event.preventDefault();
        }
    });
    document.addEventListener('contextmenu', event => event.preventDefault());

    let defaultVolume = 0.5;

    playBtn.addEventListener('click', togglePlay); // Основной триггер
    muteBtn.addEventListener('click', toggleMute);

    volumeBar.addEventListener('mousedown', startVolumeChange);
    document.addEventListener('mousemove', changeVolume);
    document.addEventListener('mouseup', stopVolumeChange);

    let isChangingVolume = false;

    function startVolumeChange(e) {
        isChangingVolume = true;
        changeVolume(e);
    }

    function changeVolume(e) {
        if (!isChangingVolume) return;
        const rect = volumeBar.getBoundingClientRect();
        let x = e.clientX - rect.left;
        x = Math.max(0, Math.min(x, rect.width));
        const volume = x / rect.width;
        setVolume(volume);
    }

    function stopVolumeChange() {
        isChangingVolume = false;
    }

    function setVolume(volume) {
        if (audioElement) {
            audioElement.volume = volume;
        }
        defaultVolume = volume;
        volumeControl.style.width = `${volume * 100}%`;
        // Сохраняем громкость, чтобы восстановить после Mute
        if (!isMuted && audioElement) {
             audioElement.volume = volume;
        }
    }

    styleButtons.forEach(button => {
        button.addEventListener('click', (e) => {
            const newStyle = e.target.dataset.style;
            if (newStyle !== currentStyle) {
                document.body.className = newStyle;
                currentStyle = newStyle;
                styleButtons.forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                updateVisualColors(); // Обновляем цвета сразу
                // Если играло, останавливаем и запускаем новый стиль
                if (playing) {
                    stopAudio(false); // Останавливаем без смены иконки
                    // Пауза для предотвращения race condition с SSE
                    setTimeout(() => {
                      if (playing) { // Проверяем, не нажал ли пользователь стоп за это время
                         initAndPlayAudio(); // Запускаем новый поток
                      }
                    }, 100);
                } else {
                    // Если не играло, просто обновляем инфо и кнопки
                     updateCurrentInfo();
                     updateButtonStyles();
                }
            }
        });
    });

    const sseUrl = 'https://nightride.fm/meta';
    const eventSource = new EventSource(sseUrl);

    eventSource.onmessage = (event) => {
        if (event.data !== "keepalive") {
            try {
                const data = JSON.parse(event.data);
                data.forEach(item => {
                    metaInfo[item.station] = item;
                });
                updateCurrentInfo();
            } catch (e) {
                console.error("Error parsing SSE data:", e);
            }
        }
    };

    function updateCurrentInfo() {
        const currentMeta = metaInfo[currentStyle];
        if (currentMeta) {
            const { artist, title, album } = currentMeta;
            // Проверяем, есть ли данные, иначе показываем стиль
            const displayTitle = (artist && title) ? `${artist} - ${title}` : `${currentStyle.toUpperCase()}`;
            const displayAlbum = album ? `(${album})` : '';
            currentInfo.textContent = `${displayTitle} ${displayAlbum}`.trim();
        } else {
            currentInfo.textContent = `${currentStyle.toUpperCase()}`; // Показываем стиль, пока нет инфо
        }
    }

    // --- Иконки кнопок (без изменений) ---
    function setPlayIcon() { /* ... */ }
    function setPauseIcon() { /* ... */ }
    function setMuteIcon() { /* ... */ }
    function setUnmuteIcon() { /* ... */ }

    // --- Обновленные функции управления аудио ---

    async function togglePlay() {
        // 1. Обработка взаимодействия пользователя (iOS требует этого для AudioContext)
        if (!userInteracted) {
            userInteracted = true; // Отмечаем, что пользователь взаимодействовал
            // Пытаемся создать AudioContext СРАЗУ при первом нажатии
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log("AudioContext created on first interaction. State:", audioContext.state);
                    // Если он сразу 'suspended', пытаемся возобновить
                    if (audioContext.state === 'suspended') {
                        await audioContext.resume();
                        console.log("AudioContext resumed on first interaction. New state:", audioContext.state);
                    }
                } catch (e) {
                    console.error("Failed to create AudioContext on interaction:", e);
                    status.textContent = 'Audio engine error';
                    return; // Не продолжаем, если контекст не создан
                }
            }
        }

        // 2. Возобновление существующего AudioContext (если он был приостановлен)
        if (audioContext && audioContext.state === 'suspended') {
            console.log("AudioContext is suspended, attempting to resume...");
            try {
                await audioContext.resume();
                console.log("AudioContext resumed. State:", audioContext.state);
            } catch (e) {
                console.error("Failed to resume AudioContext:", e);
                // Можно показать ошибку пользователю
            }
        }

        // 3. Переключение состояния Play/Pause
        if (!playing) {
            // Если AudioContext все еще не создан (ошибка выше?), выйти
             if (!audioContext) {
                 console.error("Cannot play: AudioContext not available.");
                 status.textContent = 'Audio engine error';
                 return;
             }
             // Начинаем воспроизведение
             initAndPlayAudio();
        } else {
            // Ставим на паузу
            pauseAudio();
        }
    }


    function initAndPlayAudio() {
        if (playing) return; // Не запускать, если уже играет

        // Создаем новый элемент Audio
        audioElement = new Audio(`https://stream.nightride.fm/${currentStyle}.mp3`);
        audioElement.crossOrigin = "anonymous";
        audioElement.volume = isMuted ? 0 : defaultVolume; // Устанавливаем громкость с учетом Mute

        status.textContent = 'Connecting...';

        audioElement.addEventListener('canplay', () => {
            console.log("'canplay' event fired");
            // Теперь, когда элемент готов, настраиваем Web Audio API
             if (audioContext && audioContext.state === 'running') {
                setupAudioNodes(); // Настраиваем узлы только если контекст готов
             } else {
                 console.warn("AudioContext not ready or running when 'canplay' fired. State:", audioContext?.state);
                 // Попытка настроить узлы может провалиться, но попробуем.
                 // Возможно, понадобится еще один resume() здесь или в setupAudioNodes.
                 if(audioContext) setupAudioNodes();
             }
        });

        audioElement.addEventListener('playing', () => {
            console.log("'playing' event fired");
            status.textContent = 'Now playing';
            playing = true;
            setPauseIcon();
            // Дополнительная проверка и запуск визуализации, если она еще не запущена
            if (analyser && !animationId) {
                 console.log("Starting visualization from 'playing' event");
                 updateVisualizers();
            }
             updateCurrentInfo(); // Обновляем инфо при начале игры
        });

        audioElement.addEventListener('pause', () => {
            console.log("'pause' event fired");
            // playing = false; // Не меняем здесь, т.к. может быть буферизация
            // setPlayIcon(); // Иконку меняем только при явной паузе
            // status.textContent = 'Paused'; // Статус меняем только при явной паузе
        });


        audioElement.addEventListener('error', (e) => {
            console.error('Audio Element Error:', e);
            status.textContent = 'Stream error';
            playing = false;
            setPlayIcon();
            stopAudio(true); // Полностью останавливаем при ошибке
        });

        // Начинаем воспроизведение
        audioElement.play().then(() => {
            console.log("audioElement.play() promise resolved.");
            // Успешный старт (но фактическое воспроизведение начнется позже)
            // playing = true; // Устанавливаем в true в событии 'playing'
            // setPauseIcon(); // Меняем иконку в событии 'playing'
        }).catch(error => {
            console.error('Error starting playback:', error);
            status.textContent = 'Playback error';
            playing = false;
            setPlayIcon();
             if (audioContext && audioContext.state === 'running') {
                 // Если контекст работает, но play() не удался, возможно стоит его приостановить?
                 // audioContext.suspend(); // Пока не будем
             }
        });
    }

    function setupAudioNodes() {
        // Проверяем еще раз перед созданием узлов
        if (!audioContext || audioContext.state !== 'running') {
            console.error("Cannot setup audio nodes: AudioContext not running. State:", audioContext?.state);
            return;
        }
         if (!audioElement) {
             console.error("Cannot setup audio nodes: audioElement is missing.");
             return;
         }
         if (sourceNode) {
            sourceNode.disconnect(); // Отключаем старый источник, если он был
         }

        console.log("Setting up audio nodes...");
        try {
            analyser = audioContext.createAnalyser();
            sourceNode = audioContext.createMediaElementSource(audioElement); // Создаем источник

            sourceNode.connect(analyser);
            analyser.connect(audioContext.destination); // Подключаем к выходу

            console.log("Audio nodes connected.");

            // Запускаем цикл анимации, если он еще не запущен
            if (!animationId) {
                console.log("Starting visualization loop from setupAudioNodes.");
                resizeCanvas(); // Устанавливаем размер перед первым рендером
                updateVisualizers();
            }
        } catch (e) {
            console.error("Error setting up audio nodes:", e);
            status.textContent = 'Visualizer error';
            // Очистка в случае ошибки
            if(sourceNode) sourceNode.disconnect();
            if(analyser) analyser.disconnect();
            analyser = null;
            sourceNode = null;
            if (animationId) {
                 window.cancelAnimationFrame(animationId);
                 animationId = null;
            }
        }
    }

    function pauseAudio() {
        if (audioElement) {
            audioElement.pause();
            status.textContent = 'Paused';
        }
        playing = false;
        setPlayIcon();
        // Останавливаем цикл анимации при паузе
        if (animationId) {
            window.cancelAnimationFrame(animationId);
            animationId = null;
            console.log("Visualization loop stopped on pause.");
        }
        // Не закрываем AudioContext при паузе, чтобы быстро возобновить
        // if (audioContext && audioContext.state === 'running') {
        //     audioContext.suspend(); // Можно приостановить для экономии ресурсов
        // }
    }

    function stopAudio(changeIcon = true) {
        console.log("Stopping audio...");
        if (audioElement) {
            audioElement.pause();
            audioElement.src = ''; // Очищаем источник
            audioElement.load(); // Прерываем загрузку
             // Удаляем все слушатели событий, чтобы избежать утечек
            audioElement.removeEventListener('canplay', setupAudioNodes);
            audioElement.removeEventListener('playing', () => { /*...*/ });
            audioElement.removeEventListener('pause', () => { /*...*/ });
            audioElement.removeEventListener('error', () => { /*...*/ });
            audioElement = null;
        }
        playing = false;
        if(changeIcon) setPlayIcon();

        // Останавливаем анимацию
        if (animationId) {
            window.cancelAnimationFrame(animationId);
            animationId = null;
            console.log("Visualization loop stopped.");
        }

        // Отключаем узлы Web Audio API перед закрытием контекста
        if (sourceNode) {
            sourceNode.disconnect();
            sourceNode = null;
        }
        if (analyser) {
            analyser.disconnect();
            analyser = null;
        }

        // Закрывать AudioContext необязательно, его можно переиспользовать.
        // Но если стили сильно разные или есть проблемы, можно и закрыть.
        // Для надежности при смене стиля или полной остановке - закроем.
        // if (audioContext && audioContext.state !== 'closed') {
        //     audioContext.close().then(() => {
        //         console.log("AudioContext closed.");
        //         audioContext = null;
        //     }).catch(error => {
        //         console.warn('Error closing AudioContext:', error);
        //         audioContext = null; // Считаем его закрытым в любом случае
        //     });
        // } else {
        //      audioContext = null; // Убедимся, что он null, если не был создан
        // }
         // Пока не будем закрывать контекст при стопе, только при смене стиля если решим
    }

    function toggleMute() {
        isMuted = !isMuted;
        if (audioElement) {
            audioElement.volume = isMuted ? 0 : defaultVolume;
        }
        // Обновляем иконку
        if (isMuted) {
            setMuteIcon();
        } else {
            setUnmuteIcon();
            // Восстанавливаем видимый уровень громкости на ползунке
            volumeControl.style.width = `${defaultVolume * 100}%`;
        }
    }

    // --- Функции визуализации (без изменений) ---
    function updateVisualizers() {
         // Добавим проверку перед рисованием
         if (!analyser || !audioContext || audioContext.state !== 'running' || !playing) {
             // Если что-то не так, или не играем, прекращаем цикл
             if (animationId) {
                 window.cancelAnimationFrame(animationId);
                 animationId = null;
                 console.log("Visualization loop stopped due to invalid state.");
             }
             // Очистим канвас на всякий случай
             clearCanvas(frequencyCanvas);
             clearCanvas(barsCanvas);
             return;
         }

        drawFrequency();
        drawBars();
        animationId = window.requestAnimationFrame(updateVisualizers); // Продолжаем цикл
    }

    function drawFrequency() {
        if (!analyser) return; // Доп. проверка
        const WIDTH = frequencyCanvas.width;
        const HEIGHT = frequencyCanvas.height;
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);

        try {
            analyser.getByteFrequencyData(dataArray);
        } catch (e) {
            console.error("Error getting frequency data:", e);
            return; // Прекращаем рисование, если ошибка
        }

        const ctx = frequencyCanvas.getContext('2d');
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        ctx.lineWidth = 1;
        // Получаем цвет динамически из CSS body
        ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('color').trim() || '#beb6a9'; // запасной цвет
        ctx.beginPath();

        const sliceWidth = WIDTH * 1.0 / (bufferLength / 4); // Используем только часть данных для визуала
        let x = 0;

        for (let i = 0; i < bufferLength / 4; i++) { // Рисуем меньше точек для производительности/вида
            const v = dataArray[i] / 128.0;
            const y = HEIGHT / 2 - (v * HEIGHT / 2); // Рисуем от центра

            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
            x += sliceWidth;
        }
        // ctx.lineTo(WIDTH, HEIGHT / 2); // Не обязательно доводить до конца
        ctx.stroke();
    }

    function drawBars() {
        if (!analyser) return; // Доп. проверка
        const WIDTH = barsCanvas.width;
        const HEIGHT = barsCanvas.height;
        // Уменьшим количество баров для лучшей производительности и вида
        const numBars = 64; // Например, 64 бара
        analyser.fftSize = numBars * 2; // Устанавливаем размер FFT соответственно
        const bufferLength = analyser.frequencyBinCount; // analyser.fftSize / 2
        const dataArray = new Uint8Array(bufferLength);

         try {
            analyser.getByteFrequencyData(dataArray);
        } catch (e) {
            console.error("Error getting frequency data for bars:", e);
            return; // Прекращаем рисование, если ошибка
        }

        const ctx = barsCanvas.getContext('2d');
        ctx.clearRect(0, 0, WIDTH, HEIGHT);

        const barWidth = (WIDTH / bufferLength) * 0.8; // Ширина бара с небольшим отступом
        const barSpacing = (WIDTH / bufferLength) * 0.2; // Отступ
        let x = 0;

        // Получаем цвета из CSS динамически
        const color1 = getComputedStyle(document.body).getPropertyValue('color').trim() || '#beb6a9';
        const color2 = getComputedStyle(document.querySelector('#currentInfo')).getPropertyValue('color').trim() || '#a923c2';

        // Создаем градиент каждый раз, т.к. цвета могут меняться
        const gradient = ctx.createLinearGradient(0, HEIGHT, 0, 0);
        gradient.addColorStop(0, color1);
        gradient.addColorStop(1, color2);

        for (let i = 0; i < bufferLength; i++) {
            const barHeight = (dataArray[i] / 255) * HEIGHT;

            ctx.fillStyle = gradient;
            ctx.fillRect(x, HEIGHT - barHeight, barWidth, barHeight);

            x += barWidth + barSpacing; // Перемещаемся к следующему бару
        }
    }

     function clearCanvas(canvas) {
        if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
     }

    function updateVisualColors() {
         // Просто очищаем канвасы, следующий кадр updateVisualizers() перерисует с новыми цветами
         clearCanvas(frequencyCanvas);
         clearCanvas(barsCanvas);
    }

    // --- Остальные функции и инициализация (без изменений) ---
    function updateButtonStyles() { /* ... */ }
    function resizeCanvas() {
        // Убедимся, что канвасы существуют
        if (frequencyCanvas) {
            frequencyCanvas.width = frequencyCanvas.offsetWidth;
            frequencyCanvas.height = frequencyCanvas.offsetHeight;
        }
         if (barsCanvas) {
            barsCanvas.width = barsCanvas.offsetWidth;
            barsCanvas.height = barsCanvas.offsetHeight;
         }
         // Перерисовываем с новыми размерами, если визуализация активна
         if(animationId) {
             updateVisualColors();
         }
    }

    // Убираем слушатели handleUserInteraction, т.к. playBtn теперь основной триггер
    // document.addEventListener('touchstart', handleUserInteraction);
    // document.addEventListener('click', handleUserInteraction);

    window.addEventListener('resize', resizeCanvas);

    // --- Инициализация при загрузке ---
    setVolume(defaultVolume); // Устанавливаем громкость по умолчанию
    updateCurrentInfo(); // Загружаем инфо сразу
    updateButtonStyles(); // Устанавливаем активную кнопку стиля
    resizeCanvas(); // Устанавливаем размер канваса при загрузке
    setPlayIcon(); // Начальная иконка - Play
    setUnmuteIcon(); // Начальная иконка - Unmute


</script>
</body>
</html>
